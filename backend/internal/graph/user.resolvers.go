package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"time"

	"github.com/dokedu/stack/backend/internal/database"
	"github.com/dokedu/stack/backend/internal/database/db"
	"github.com/dokedu/stack/backend/internal/graph/model"
	"github.com/dokedu/stack/backend/internal/helper"
	"github.com/dokedu/stack/backend/internal/middleware"
	"github.com/dokedu/stack/backend/internal/msg"
	"github.com/jackc/pgx/v5/pgtype"
	gonanoid "github.com/matoous/go-nanoid/v2"
	"github.com/samber/lo"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	organisation, err := r.DB.GLOBAL_OrganisationById(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	userParams := db.CreateUserParams{
		Email:          input.Email,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		OrganisationID: currentUser.OrganisationID,
	}

	user, err := r.DB.CreateUser(ctx, userParams)
	if err != nil {
		return nil, err
	}

	// Email the user
	token := gonanoid.Must(32)
	recoveryTokenParams := db.UpdateUserRecoveryTokenParams{
		ID:            user.ID,
		RecoveryToken: pgtype.Text{String: token, Valid: true},
	}
	_, _ = r.DB.UpdateUserRecoveryToken(ctx, recoveryTokenParams)
	if err != nil {
		return nil, err
	}

	if input.Email != "" {
		err = r.Mailer.SendInvite(input.Email, user.FirstName, organisation.Name, token)
		if err != nil {
			return nil, err
		}
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	updateUserParams := db.UpdateUserParams{
		ID:             input.ID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		OrganisationID: currentUser.OrganisationID,
	}
	user, err := r.DB.UpdateUser(ctx, updateUserParams)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	// Delete the user by setting the deleted_at field to the current time
	user, err := r.DB.DeleteUserById(ctx, db.DeleteUserByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// Remove the sessions for the user
	err = r.DB.GLOBAL_DeleteSessionsByUserID(ctx, user.ID)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}

	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	query := r.DB.NewQueryBuilder().
		Select("*").
		From("users").
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(uint64(pageLimit)).
		Offset(uint64(pageOffset))

	if filter != nil {
		if filter.OrderBy != nil {
			switch *filter.OrderBy {
			case model.UserOrderByFirstNameAsc:
				query = query.OrderBy("first_name ASC, last_name ASC")
			case model.UserOrderByFirstNameDesc:
				query = query.OrderBy("first_name DESC, last_name DESC")
			case model.UserOrderByLastNameAsc:
				query = query.OrderBy("last_name ASC, first_name ASC")
			case model.UserOrderByLastNameDesc:
				query = query.OrderBy("last_name DESC, first_name DESC")
			default:
				query = query.OrderBy("last_name ASC, first_name ASC")
			}
		}

		if filter.ShowDeleted != nil && *filter.ShowDeleted {
			query = query.Where("deleted_at IS NOT NULL")
		} else {
			query = query.Where("deleted_at IS NULL")
		}
	}

	if search != nil && *search != "" {
		query = query.Where("first_name || ' ' || last_name ILIKE ?", "%"+*search+"%")
	}

	users, err := database.ScanSelectMany[db.User](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	count, err := r.DB.UserListCount(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}
	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, int(count))
	if err != nil {
		return nil, err
	}

	return &model.UserConnection{
		Edges:      lo.ToSlicePtr(users),
		PageInfo:   pageInfo,
		TotalCount: int(count),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	userByIdParams := db.UserByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	}

	user, err := r.DB.UserById(ctx, userByIdParams)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthenticated
	}

	return &currentUser.User, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// InviteAccepted is the resolver for the inviteAccepted field.
func (r *userResolver) InviteAccepted(ctx context.Context, obj *db.User) (bool, error) {
	_, ok := middleware.GetUser(ctx)
	if !ok {
		return false, msg.ErrUnauthenticated
	}

	if obj.Password.Valid {
		return true, nil
	}

	return false, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
